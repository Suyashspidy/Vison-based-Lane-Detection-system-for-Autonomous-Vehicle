# -*- coding: utf-8 -*-
"""lane_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cArkpS7A2HwMdvcYE2MhgDfRTYr2McGe
"""

import numpy as np
import matplotlib.image as mpimg
import cv2
from docopt import docopt
from IPython.display import HTML
from IPython.core.display import Video
from moviepy.editor import VideoFileClip
from CameraCalibration import CameraCalibration
from Thresholding import *
from PerspectiveTransformation import *
from LaneLines import *

class FindLaneLines:
  def __init__(self):
    """ Init Application"""
    self.calibration = CameraCalibration('camera_cal', 9, 6)
    self.thresholding = Thresholding()
    self.transform = PerspectiveTransformation()
    self.lanelines = LaneLines()

  def forward(self, img):
    out_img = np.copy(img)
    img = self.calibration.undistort(img)
    img = self.transform.forward(img)
    img = self.thresholding.forward(img)
    img = self.lanelines.forward(img)
    img = self.transform.backward(img)

    out_img = cv2.addWeighted(out_img, 1, img, 0.6, 0)
    out_img = self.lanelines.plot(out_img)
    return out_img

  def process_image(self, input_path, output_path):
    img = mpimg.imread(input_path)
    out_img = self.forward(img)
    mpimg.imsave(output_path, out_img)

  def process_video(self, input_path, output_path):
    clip = VideoFileClip(input_path)
    out_clip = clip.fl_image(self.forward)
    out_clip.write_videofile(output_path, audio=False)

def main():
  findLaneLines = FindLaneLines()
  findLaneLines.process_video("challenge_video.mp4","output.mp4")

if __name__ == "__main__":
  main()

!pip install rospy

import rospy
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import numpy as np
import torch
import torchvision.transforms as transforms
from model import SCNN, FastSCNN  # Import your SCNN and FastSCNN models from your implementation

class LaneDetectorROS:
    def __init__(self):
        rospy.init_node('lane_detector')
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber('/camera/image', Image, self.image_callback)
        self.model = SCNN()  # Initialize your SCNN model
        # self.model = FastSCNN()  # Initialize your FastSCNN model
        self.model.load_state_dict(torch.load('model.pth'))  # Load your trained model weights
        self.model.eval()
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    def image_callback(self, data):
        cv_image = self.bridge.imgmsg_to_cv2(data, 'bgr8')
        lane_image = self.process_image(cv_image)
        self.publish_lane_image(lane_image)

    def process_image(self, cv_image):
        # Preprocess image
        transform = transforms.Compose([
            transforms.ToPILImage(),
            transforms.Resize((256, 512)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ])
        input_image = transform(cv_image).unsqueeze(0).to(self.device)

        # Forward pass through the model
        with torch.no_grad():
            output = self.model(input_image)

        # Post-process output
        output = torch.argmax(output, dim=1).squeeze().cpu().numpy()
        lane_image = np.zeros_like(cv_image)
        lane_image[output == 1] = [0, 255, 0]  # Lane pixels marked as green

        return lane_image

    def publish_lane_image(self, lane_image):
        lane_image_msg = self.bridge.cv2_to_imgmsg(lane_image, 'bgr8')
        self.lane_image_pub.publish(lane_image_msg)

if __name__ == '__main__':
    try:
        lane_detector = LaneDetectorROS()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass